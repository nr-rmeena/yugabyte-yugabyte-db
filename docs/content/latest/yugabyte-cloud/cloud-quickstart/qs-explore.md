---
title: Explore Yugabyte SQL
linkTitle: Explore distributed SQL
description: Use distributed SQL to explore core features of YugabteDB.
headcontent:
image: /images/section_icons/index/quick_start.png
menu:
  latest:
    identifier: qs-explore-1-ysql
    parent: cloud-quickstart
    weight: 400
type: page
isTocNested: true
showAsideToc: true
---

After [creating a free cluster](../qs-add/), [connecting to the cluster](../qs-connect/) using the cloud shell, and [creating a database (yb_demo) and loading some data](../qs-data/), you can start exploring YugabyteDB's PostgreSQL-compatible, fully-relational Yugabyte SQL API.

This exercise assumes you are already connected to your cluster using the `ysqlsh` shell, have created the `yb_demo` database, and loaded the sample data.

## Explore YugabyteDB

To display the schema of the `emp` table, enter the following command:

```sql
yb_demo=# \d emp
```

```output
                               Table "public.emp"
   Column   |  Type   | Collation | Nullable |             Default              
------------+---------+-----------+----------+----------------------------------
 empno      | integer |           | not null | generated by default as identity
 ename      | text    |           | not null | 
 job        | text    |           |          | 
 mgr        | integer |           |          | 
 hiredate   | date    |           |          | 
 sal        | integer |           |          | 
 comm       | integer |           |          | 
 deptno     | integer |           | not null | 
 email      | text    |           |          | 
 other_info | jsonb   |           |          | 
Indexes:
    "pk_emp" PRIMARY KEY, lsm (empno HASH)
    "emp_email_uk" UNIQUE CONSTRAINT, lsm (email HASH)
Check constraints:
    "emp_email_check" CHECK (email ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'::text)
Foreign-key constraints:
    "fk_deptno" FOREIGN KEY (deptno) REFERENCES dept(deptno)
    "fk_mgr" FOREIGN KEY (mgr) REFERENCES emp(empno)
Referenced by:
    TABLE "emp" CONSTRAINT "fk_mgr" FOREIGN KEY (mgr) REFERENCES emp(empno)
```

### Queries, joins, aggregates, graph, and pivot

Use a self-join query to list the employees earning more than their managers.

```sql
select
    employee.ename,
    employee.sal,
    manager.ename as "manager ename",
    manager.sal as "manager sal"
from
    emp employee
join emp manager on
    employee.mgr = manager.empno
where
    manager.sal<employee.sal
order by employee.sal;
```

```output
 ename | sal  | manager ename | manager sal 
-------+------+---------------+-------------
 FORD  | 3000 | JONES         |        2975
 SCOTT | 3000 | JONES         |        2975
(2 rows)
```

Use a recursive common table expression (CTE) to show the manager hierarchy.

```sql
with recursive emp_manager as (
    select empno, ename, ename as path
        from emp where ename='JONES'
    union all
    select emp.empno, emp.ename, emp_manager.path || ' manages ' || emp.ename
        from emp join emp_manager on emp.mgr = emp_manager.empno
)
select * from emp_manager;
```

```output
 empno | ename |               path                
-------+-------+-----------------------------------
  7566 | JONES | JONES
  7788 | SCOTT | JONES manages SCOTT
  7902 | FORD  | JONES manages FORD
  7876 | ADAMS | JONES manages SCOTT manages ADAMS
  7369 | SMITH | JONES manages FORD manages SMITH
(5 rows)
```

Use analytic window functions to compare the hiring time interval by department.

```sql
select
    dname,ename,job,
    coalesce (
        'hired '||to_char(hiredate -
        lag(hiredate) over (per_dept_hiredate),'999')||' days after '||
        lag(ename) over (per_dept_hiredate),
        format('(1st hire in %L)',dname)
    ) as "last hire in dept"
    from emp join dept using(deptno)
    window per_dept_hiredate
    as (partition by dname order by hiredate)
    order by dname,hiredate;
```

```output
   dname    | ename  |    job    |      last hire in dept       
------------+--------+-----------+------------------------------
 ACCOUNTING | CLARK  | MANAGER   | (1st hire in 'ACCOUNTING')
 ACCOUNTING | KING   | PRESIDENT | hired  161 days after CLARK
 ACCOUNTING | MILLER | CLERK     | hired   67 days after KING
 RESEARCH   | SMITH  | CLERK     | (1st hire in 'RESEARCH')
 RESEARCH   | JONES  | MANAGER   | hired  106 days after SMITH
 RESEARCH   | FORD   | ANALYST   | hired  245 days after JONES
 RESEARCH   | SCOTT  | ANALYST   | hired  371 days after FORD
 RESEARCH   | ADAMS  | CLERK     | hired   34 days after SCOTT
 SALES      | ALLEN  | SALESMAN  | (1st hire in 'SALES')
 SALES      | WARD   | SALESMAN  | hired    2 days after ALLEN
 SALES      | BLAKE  | MANAGER   | hired   68 days after WARD
 SALES      | TURNER | SALESMAN  | hired  130 days after BLAKE
 SALES      | MARTIN | SALESMAN  | hired   20 days after TURNER
 SALES      | JAMES  | CLERK     | hired   66 days after MARTIN
(14 rows)
```

Use a crosstab pivot query to show the sum of salary per job by department.

```sql
select job, dname, sum(sal)
    from emp join dept using(deptno)
    group by dname, job
    \crosstabview
```

```output
    job    | ACCOUNTING | SALES | RESEARCH 
-----------+------------+-------+----------
 PRESIDENT |       5000 |       |         
 CLERK     |       1300 |   950 |     1900
 SALESMAN  |            |  5600 |         
 MANAGER   |       2450 |  2850 |     2975
 ANALYST   |            |       |     6000
(5 rows)
```

### JSON, text search, and date intervals

Use text pattern matching with an array of regular expressions to filter on e-mail.

```sql
select * from emp
    where email ~ any ( ARRAY[ '@.*\.org$' , '@gmail\.' ] );
```

```output
 empno | ename |   job   | mgr  |  hiredate  | sal  | comm | deptno |      email      | other_info 
-------+-------+---------+------+------------+------+------+--------+-----------------+------------
  7876 | ADAMS | CLERK   | 7788 | 1983-01-12 | 1100 |      |     20 | ADAMS@acme.org  | 
  7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975 |      |     20 | JONES@gmail.com | 
  7900 | JAMES | CLERK   | 7698 | 1981-12-03 |  950 |      |     30 | JAMES@acme.org  | 
(3 rows)
```

Create a GIN index on a JSON document and query on the attribute list. (Feature only available in v2.11.)

1. Create the GIN index on the JSON document.

    ```sql
    create index emp_skills on emp using gin((other_info->'skills'));
    ```

1. Query on the JSON attribute list.

    ```sql
    select * from emp where other_info->'skills' @> '"SQL"';
    ```

1. Explain the plan to verify that the index is used.

    ```sql
    explain select * from emp where other_info->'skills' @> '"SQL"';
    ```

Create a text search index on the description column and query for words. (Feature only available in v2.11.)

1. Create text search index on description column.

    ```sql
    create index dept_description_text_search on dept 
        using ybgin (( to_tsvector('simple',description) ));
    ```

1. Query on description for matching words.

    ```sql
    select * from dept
        where to_tsvector('simple',description) @@ to_tsquery('simple','responsible & services');
    ```

1. Explain the plan to verify that the index is used.

    ```sql
    explain select * from dept 
        where to_tsvector('simple',description) @@ to_tsquery('simple','responsible & services');
    ```

Use arithmetic on date intervals to find employees with overlapping evaluation periods.

```sql
with emp_evaluation_period as (
    select ename,deptno,hiredate,
        hiredate + case when job in ('MANAGER','PRESIDENT')
        then interval '3 month' else interval '4 weeks'
        end evaluation_end from emp
    )
select * from emp_evaluation_period e1
    join emp_evaluation_period e2
    on (e1.ename>e2.ename) and (e1.deptno=e2.deptno)
    where (e1.hiredate,e1.evaluation_end)
    overlaps (e2.hiredate,e2.evaluation_end);
```

```output
 ename  | deptno |  hiredate  |   evaluation_end    | ename  | deptno |  hiredate  |   evaluation_end    
--------+--------+------------+---------------------+--------+--------+------------+---------------------
 MILLER |     10 | 1982-01-23 | 1982-02-20 00:00:00 | KING   |     10 | 1981-11-17 | 1982-02-17 00:00:00
 TURNER |     30 | 1981-09-08 | 1981-10-06 00:00:00 | MARTIN |     30 | 1981-09-28 | 1981-10-26 00:00:00
 WARD   |     30 | 1981-02-22 | 1981-03-22 00:00:00 | ALLEN  |     30 | 1981-02-20 | 1981-03-20 00:00:00
(3 rows)
```

### DML, prepared statements, and stored procedures

Use a returning clause to update and return the new values in the same call.

```sql
update emp set sal=sal+100
    where job != 'MANAGER'
    returning ename,sal as new_salary;
```

```output
 ename  | new_salary 
--------+------------
 SMITH  |        900
 ADAMS  |       1200
 WARD   |       1350
 KING   |       5100
 FORD   |       3100
 MARTIN |       1350
 JAMES  |       1050
 ALLEN  |       1700
 MILLER |       1400
 SCOTT  |       3100
 TURNER |       1600
(11 rows)

UPDATE 11
```

Use a prepared statement with typed input to prevent SQL injection.

1. Prepare the statement.

    ```sql
    prepare employee_salary(int) as
        select ename,sal from emp where empno=$1;
    ```

    ```output
    PREPARE
    ```

1. Execute the prepared statement with one value.

    ```sql
    execute employee_salary(7900);
    ```

    ```output
        ename | sal  
    -------+------
    JAMES | 1050
    (1 row)
    ```

1. Execute the same prepared statement with another value.

    ```sql
    execute employee_salary(7902);
    ```

    ```output
    ename | sal  
    -------+------
    FORD  | 3100
    (1 row)
    ```

1. Deallocate the prepared statement.

    ```sql
    deallocate employee_salary;
    ```

    ```output
    DEALLOCATE
    ```

Use a procedure to encapsulate transactions with error handling.

1. Create the procedure with the business logic.

    ```sql
    create or replace procedure commission_transfer(empno1 int, empno2 int, amount int) as $$
    begin
        update emp set comm=comm-commission_transfer.amount
            where empno=commission_transfer.empno1 and comm>commission_transfer.amount;
        if not found then raise exception 'Cannot transfer % from %',amount,empno1; end if;
        update emp set comm=comm+commission_transfer.amount
            where emp.empno=commission_transfer.empno2;
        if not found then raise exception 'Cannot transfer from %',empno2; end if;
    end;
    $$ language plpgsql;
    ```

    ```output
    CREATE PROCEDURE
    ```

1. Call the procedure.

    ```sql
    call commission_transfer(7521,7654,100);
    ```

    ```output
    CALL
    ```

1. Check the result.

    ```sql
    select * from emp where comm is not null;
    ```

    ```output
    empno | ename  |   job    | mgr  |  hiredate  | sal  | comm | deptno |        email        | other_info 
    -------+--------+----------+------+------------+------+------+--------+---------------------+------------
      7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1350 |  400 |     30 | WARD@compuserve.com | 
      7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1350 | 1500 |     30 | MARTIN@acme.com     | 
      7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1700 |  300 |     30 | ALLEN@acme.com      | 
      7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1600 |    0 |     30 | TURNER@acme.com     | 
    (4 rows)
    ```

1. Get the custom error message when the business condition is not met.

    ```sql
    call commission_transfer(7521,7654,999999);
    ```

    ```output
    ERROR:  Cannot transfer 999999 from 7521
    CONTEXT:  PL/pgSQL function commission_transfer(integer,integer,integer) line 5 at RAISE
    ```

### DDL, triggers, and online index creation

Record the last update time of each row automatically.

1. Add a column to store the last update time.

    ```sql
    alter table dept add last_update timestamptz;
    ```

    ```output
    ALTER TABLE
    ```

1. Add a function to set the last update time.

    ```sql
    create or replace function dept_last_update() returns trigger as $$
        begin
            new.last_update:=transaction_timestamp();
            return new;
        end;
    $$ language plpgsql;
    ```

    ```output
    CREATE FUNCTION
    ```

1. Create a trigger to call the function on each update.

    ```sql
    create trigger dept_last_update
        before update on dept
        for each row
        execute procedure dept_last_update();
    ```

    ```output
    CREATE TRIGGER
    ```

1. Display the current state of the table.

    ```sql
    select deptno,dname,loc,last_update from dept;
    ```

    ```output
    deptno |   dname    |   loc    | last_update 
    --------+------------+----------+-------------
        10 | ACCOUNTING | NEW YORK | 
        20 | RESEARCH   | DALLAS   | 
        30 | SALES      | CHICAGO  | 
        40 | OPERATIONS | BOSTON   | 
    (4 rows)
    ```

1. Update multiple rows in one transaction.

    ```sql
    begin transaction;
    update dept set loc='SUNNYVALE' where deptno=30;
    select pg_sleep(3);
    update dept set loc='SUNNYVALE' where deptno=40;
    commit;
    ```

    ```output
    BEGIN
    UPDATE 1
    pg_sleep 
    ----------
    
    (1 row)
    UPDATE 1
    COMMIT
    ```

1. Display the new state of the table.

    ```sql
    select deptno,dname,loc,last_update from dept;
    ```

    ```output
    deptno |   dname    |    loc    |          last_update          
    --------+------------+-----------+-------------------------------
        10 | ACCOUNTING | NEW YORK  | 
        20 | RESEARCH   | DALLAS    | 
        30 | SALES      | SUNNYVALE | 2022-01-11 22:15:34.831474+00
        40 | OPERATIONS | SUNNYVALE | 2022-01-11 22:15:34.831474+00
    (4 rows)
    ```

Create a new table and an index to avoid table scans and sorts.

1. Create a table with randomly generated rows.

    ```sql
    create table demo as select generate_series(1,42) num, round(10*random()) val;
    ```

    ```output
    SELECT 42
    ```

1. Create the index.

    ```sql
    create index demo_val on demo(val,num);
    ```

    ```output
    CREATE INDEX
    ```

1. Analyze to gather optimizer statistics.

    ```sql
    analyze demo;
    ```

    ```output
    ANALYZE
    ```

1. Query the Top-3 numbers for a specific value.

    ```sql
    select * from demo where val=5 order by num fetch first 3 rows only;
    ```

    ```output
    num | val 
    -----+-----
      11 |   5
      35 |   5
    (2 rows)
    ```

1. Use Explain to verify that no Sort operation is needed thanks to the index.

    ```sql
    explain analyze select * from demo where val=5 order by num fetch first 3 rows only;
    ```

    ```output
                                                            QUERY PLAN                                                         
    ---------------------------------------------------------------------------------------------------------------------------
    Limit  (cost=0.00..3.19 rows=3 width=12) (actual time=0.712..0.715 rows=2 loops=1)
      ->  Index Only Scan using demo_val on demo  (cost=0.00..4.47 rows=4 width=12) (actual time=0.710..0.713 rows=2 loops=1)
            Index Cond: (val = '5'::double precision)
            Heap Fetches: 0
    Planning Time: 0.086 ms
    Execution Time: 0.750 ms
    (6 rows)
    ```

1. Clean up the table for this execise.

    ```sql
    drop table if exists demo;
    ```

    ```output
    DROP TABLE
    ```

## Next steps

- [Develop an application](../../cloud-develop/)
- [Deploy production clusters](../../cloud-basics/create-clusters/)
- [Authorize access to your cluster](../../cloud-secure-clusters/add-connections/)
- [Connect to clusters](../../cloud-connect/)
- [Add database users](../../cloud-secure-clusters/add-users/)
