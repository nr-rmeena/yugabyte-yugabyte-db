---
title: Change data capture (CDC)
headerTitle: Change data capture (CDC)
linkTitle: Change data capture (CDC)
description: Learn how YugabyteDB supports asynchronous replication of data changes (inserts, updates, and deletes) to external databases or applications.
beta: /latest/faq/general/#what-is-the-definition-of-the-beta-feature-tag
aliases:
  - /latest/architecture/cdc-architecture/
  - /latest/architecture/change-data-capture/
menu:
  latest:
    parent: architecture-docdb-replication
    identifier: architecture-docdb-replication-cdc
    weight: 1160
type: page
isTocNested: true
showAsideToc: true
---

Change data capture (CDC) in YugabyteDB provides technology to ensure that any changes in data (inserts, updates, and deletions) are identified, captured, and automatically applied to another data repository instance or made available for consumption by applications and other tools.

## Use cases

Change data capture is useful in a number of scenarios, such as the ones described here.

### Microservice-oriented architectures

Some microservices require a stream of changes to the data and using CDC in YugabyteDB can provide consumable data changes to CDC subscribers.

### Asynchronous replication to remote systems

Remote systems may subscribe to a stream of data changes and then transform and consume the changes. Maintaining separate database instances for transactional and reporting purposes can be used to manage workload performance.

### Multiple data center strategies

Maintaining multiple data centers enables enterprises to provide:

- High availability (HA) — Redundant systems help ensure that your operations virtually never fail.
- Geo-redundancy — Geographically dispersed servers provide resiliency against catastrophic events and natural disasters.

### Compliance and auditing

Auditing and compliance requirements can require you to use CDC to maintain records of data changes.

{{< note title="Note" >}}

In the sections below, the terms "data center", "cluster", and "universe" are used interchangeably. We assume here that each YB universe is deployed in a single data center.

{{< /note >}}

## Process architecture
To be updated: new Architecture 
<!--- ![CDC process architecture](/images/architecture/cdc-2dc/process-architecture.png) --->

### CDC streams

Creating a new CDC stream will return a stream UUID. This is facilitated via the [yb-admin]() tool with the following command:

```
./yb-admin create_change_data_stream ysql.yugabyte
```

One can also view all the created change data streams by using

```
./yb-admin list_change_data_streams
```

### Debezium

To consume the events generated by CDC, we will be using Debezium as the connector. It is an open source distributed platform that needs to be pointed at the database using the stream ID. Steps to setup Debezium for YugabyteDB CDC are documented [here](https://github.com/vaibhav-yb/yugabyte-db/blob/cdc-docs/docs/content/latest/cdc/running_cdc_with_debezium.md#running-cdc-with-debezium-locally).

### CDC yb-admin commands

Listed below are yb-admin commands for Change Data streams manipulation.

* #### create_change_data_stream
    This command is used to create a stream ID for a given namespace. After executing this, you will get a CDC Stream ID as the response. For example, to create a stream on a namespace “demo”, use the following:
    ```bash
    $ ./yb-admin create_change_data_stream ysql.yugabyte
    CDC Stream ID: d540f5e4890c4d3b812933cbfd703ed3
    ```
  
* #### list_change_data_stream
    This command lists all the stream IDs present in the Yugabyte cluster pertaining to Change Data Capture.
    ```bash
    # No tables exist in the namespace in this case
    $ ./yb-admin list_change_data_streams
    CDC Streams:
    streams {
      stream_id: "d540f5e4890c4d3b812933cbfd703ed3"
      options {
        key: "id_type"
        value: "NAMESPACEID"
      }
      options {
        key: "checkpoint_type"
        value: "EXPLICIT"
      }
      options {
        key: "source_type"
        value: "CDCSDK"
      }
      options {
        key: "record_format"
        value: "PROTO"
      }
      options {
        key: "record_type"
        value: "CHANGE"
      }
      options {
        key: "state"
        value: "ACTIVE"
      }
    }

    # if there are any tables in the database which are valid for CDC (tables
    # having a primary key), the table IDs for them will be there too
    CDC Streams:
    streams {
      stream_id: "d540f5e4890c4d3b812933cbfd703ed3"
      table_id: "000033e1000030008000000000004000"
      options {
        key: "id_type"
        value: "NAMESPACEID"
      }
      options {
        key: "checkpoint_type"
        value: "EXPLICIT"
      }
      options {
        key: "source_type"
        value: "CDCSDK"
      }
      options {
        key: "record_format"
        value: "PROTO"
      }
      options {
        key: "record_type"
        value: "CHANGE"
      }
      options {
        key: "state"
        value: "ACTIVE"
      }
    }
    ```
* #### get_change_data_stream_info
    This command is used to list the information related to the DB stream ID you are passing. It will list the namespace ID and the table IDs associated with a DB stream ID.
    ```bash
    $ ./yb-admin get_change_data_stream_info d540f5e4890c4d3b812933cbfd703ed3
    CDC DB Stream Info:
    table_info {
      stream_id: "d540f5e4890c4d3b812933cbfd703ed3"
      table_id: "000033e1000030008000000000004000"
    }
    namespace_id: "000033e1000030008000000000000000"

    # If no tables exist in the namespace, you’d still get the info, but there # will be no table_ids in the response:
    CDC DB Stream Info:
    namespace_id: "000033e1000030008000000000000000"
    ```
  
* #### delete_change_data_stream
    This command is used to delete a DB Stream ID.
    ```bash
    $ ./yb-admin delete_change_data_stream d540f5e4890c4d3b812933cbfd703ed3
    Successfully deleted CDC DB Stream ID: d540f5e4890c4d3b812933cbfd703ed3
    ```

### Pushing changes to external systems

Using the Debezium connector for YugabyteDB, we can push the changes from YugabyteDB to a Kafka topic which can then be used by any end user application for the processing and analysis of the records.

### CDC guarantees

#### Per-tablet ordered delivery guarantee

All data changes for one row, or multiple rows in the same tablet, will be received in the order in which they occur. Due to the distributed nature of the problem, however, there is no guarantee for the order across tablets.

For example, let us imagine the following scenario:

- Two rows are being updated concurrently.
- These two rows belong to different tablets.
- The first row `row #1` was updated at time `t1` and the second row `row #2` was updated at time `t2`.

In this case, it is possible for CDC to push the later update corresponding to `row #2` change to Kafka before pushing the earlier update, corresponding to `row #1`.

#### At-least-once delivery

Updates for rows will be pushed at least once. With "at-least-once" delivery, you will never lose a message, but might end up being delivered to a CDC consumer more than once. This can happen in case of tablet leader change, where the old leader already pushed changes to Kafka, but the latest pushed `op id` was not updated in `cdc_subscribers` table.

For example, imagine a CDC client has received changes for a row at times t1 and t3. It is possible for the client to receive those updates again.

#### No gaps in change stream

When you have received a change for a row for timestamp `t`, you will not receive a previously unseen change for that row from an earlier timestamp. This guarantees that receiving any change implies that all earlier changes have been received for a row.
