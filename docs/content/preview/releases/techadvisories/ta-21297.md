---
headerTitle: Missing writes during Batch Execution in a transaction
linkTitle: TA-21297
headcontent: Published on&#58; March 25, 2024
description: Missing writes during Batch Execution in a transaction
type: docs
showRightNav: true
cascade:
  unversioned: true
menu:
  preview_releases:
    identifier: ta-21297
    parent: tech-advisories
    weight: 1
type: docs
---

| Affected APIs | Affected Releases |  Related Issues   |
| :------------ | :---------------- | :---------------- |
| YSQL          | All               | {{<issue 21297>}} |

## Description

Due to a day-0 issue with transaction retries it is possible that, in specific circumstances, a transaction is _partially_ executed and no error is returned. This is an atomicity violation and may result in data loss.

This can only happen when:

- you use some form of write "batch statement" (for example, multiple write statements into the same message) specifically as the first message/statement in the transaction
- a transaction conflict occurs for any but the first internal statement in that batch statement.

## Mitigation

The workaround is to add a read statement (for example, `SELECT 1`) as the first statement in each transaction. You can also disable the transaction retries according to the installed release as follows:

1. For versions prior to `2.18.5.1`, `2.18.6.0`, `2.20.1.1`, `2.20.2.0`, and `2.21.0.0`, set the following flags:

    ```sql
    ysql_max_read_restart_attempts = 0
    ysql_max_write_restart_attempts = 0
    ```

1. For versions starting from `2.18.5.1`, `2.18.6.0`, `2.20.1.1`, `2.20.2.0`, and `2.21.0.0`, set the following YSQL configuration parameter:

    ```sql
    yb_max_query_layer_retries = 0
    ```

## Details

In YSQL if we receive certain errors from the storage layer (e.g. transaction conflict and read-restart errors) we try to internally retry the transaction if possible. To ensure correctness we check that we have not sent any response to the client/user before retrying.

Normally, this check implies we only retry in case the error is hit during the first statement in a transaction -- as after the first statement is executed we respond to the client and disable retries for this transaction until it's done. So we don't need to replay the entire transaction, just the current statement. However, if the first statement uses some form of batching (one message including multiple statements) then we may not respond to the client until the full batch is executed. But we may hit an error for the Nth statement in the batch -- and then only retry that statement.
This leads to all statements before the conflicting one being missed in the retried transaction.

There are two currently known main cases where this can occur:

- Main case, a wire-protocol Batch Statement
- A message with multiple semicolon-separated individual statements (Java driver will split that into individual messages and avoid the issue, but other may behave differently)

### Examples

```java
connection.setAutoCommit(false);
statement.addBatch("INSERT INTO t2 VALUES (1,2,3)");
statement.addBatch("INSERT INTO t2 VALUES (2,3,4)");
statement.addBatch("INSERT INTO t2 VALUES (3,4,5)");
statement.addBatch("UPDATE t1 SET v2 = src + 1 WHERE k = 1");
statement.executeBatch();
connection.commit();
```

```sql
BEGIN
Batch Statement
      Write statement 1
Write statement 2
…
Write statement N-1
Write statement N ← if conflict here we only retry current stmt

Statement N+1
Statement N+2
…
Statement M
BatchExecute → not respond to client until here
…
COMMIT
```