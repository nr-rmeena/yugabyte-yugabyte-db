import re
import os
import typing

import cpp_parser

TEST_SUFFIX = "_test"
CMAKE_FILE = "CMakeLists.txt"
IGNORED_HEADERS = re.compile(
    R"^google/protobuf/generated_enum_reflection\.h$")

parsed_files = {}


# Add rhs to lhs, setting value to `true` if it is `true` in at least one dict.
def merge_headers(lhs: typing.Dict[str, bool], rhs: typing.Dict[str, bool]):
    for header, trivial in rhs.items():
        if header not in lhs:
            lhs[header] = trivial
        else:
            lhs[header] = trivial or lhs[header]


# Container for system and project headers.
class Headers:
    def __init__(self):
        self.system: typing.Dict[str, bool] = dict()
        self.project: typing.Dict[str, bool] = dict()

    def extend(self, rhs):
        merge_headers(self.system, rhs.system)
        merge_headers(self.project, rhs.project)

    # Generate precompiled headers file for specified library.
    def generate(self, path, libname):
        if len(self.system) == 0:
            return
        categories = ([], [], [], [])
        for header in sorted(self.system.keys()):
            if IGNORED_HEADERS.match(header) or not self.system[header]:
                continue
            idx = cpp_parser.header_category(header, True)
            if header == 'ev++.h':
                categories[idx].append(
                    '#undef EV_ERROR // On mac is it defined as some number, '
                    'but ev++.h uses it in enum')
            categories[idx].append("#include <{}>".format(header))
        for header in sorted(self.project.keys()):
            if IGNORED_HEADERS.match(header) or not self.project[header]:
                continue
            if libname == 'gutil':
                continue
            if header.startswith('yb/gutil') or \
                    (libname != 'util' and header.startswith('yb/util')):
                categories[3].append('#include "{}"'.format(header))

        lines = [
            "// Copyright (c) YugaByte, Inc.",
            "// This file was auto generated by python/yb/gen_pch.py",
            "#pragma once",
        ]
        for category in categories:
            if len(category) == 0:
                continue
            lines.append('')
            for include in category:
                lines.append(include)

        body = ''
        for i in range(len(lines)):
            body += lines[i]
            body += '\n'

        pch_name = os.path.join(path, libname + '_pch.h')
        # Don't overwrite file with the same content.
        if os.path.exists(pch_name):
            with open(pch_name) as inp:
                if inp.read() == body:
                    print("Skip", path, libname)
                    return
        with open(pch_name, 'w') as out:
            out.write(body)
        print("Generate", path, libname)


# Get headers for specified file.
def process_file(fname: str) -> Headers:
    if fname in parsed_files:
        return parsed_files[fname]
    result = Headers()
    parsed_file = cpp_parser.parse_file(fname)
    if parsed_file.trivial:
        for include in parsed_file.includes:
            if include.system:
                result.system[include.name] = include.trivial
            else:
                result.project[include.name] = include.trivial
            if include.trivial and not include.system:
                for path in ('src', 'build/latest/src'):
                    include_path = os.path.join(path, include.name)
                    if os.path.exists(include_path):
                        result.extend(process_file(include_path))
                        break

    parsed_files[fname] = result
    return result


# Split path into tokens.
def split_path(path: str) -> typing.List[str]:
    result = []
    while len(path) != 0:
        result.append(os.path.basename(path))
        path = os.path.dirname(path)
    return result


def main():
    libs = {}
    # Enumerate all files and group them by library.
    for root in ['src', 'ent/src']:
        for (path, dirs, files) in os.walk(root):
            if path.startswith("src/yb/rocksdb/port/win") or \
                    path.startswith("src/yb/rocksdb/examples") or \
                    path.startswith("src/yb/rocksdb/tools/rdb"):
                continue
            has_cmake = CMAKE_FILE in files
            lib = None
            for check_path in ('src/yb/yql/cql/ql', 'src/yb/yql/pggate'):
                if path.startswith(check_path):
                    if check_path not in libs:
                        libs[check_path] = []
                    lib = libs[check_path]
                    break
            if lib is None:
                if has_cmake:
                    libs[path] = []
                    lib = libs[path]
                else:
                    libpath = path
                    while len(libpath) != 0:
                        if libpath.startswith('ent/'):
                            libpath = libpath[4:]
                        else:
                            libpath = os.path.dirname(libpath)
                        if libpath in libs:
                            lib = libs[libpath]
                            break
            print(path, lib)
            if lib is None:
                continue
            for file in files:
                if file.endswith('.cc'):
                    lib.append(os.path.join(path, file))

    print(libs.keys())

    # Generate precompiled header for each library.
    for path, files in libs.items():
        headers = Headers()

        for file in files:
            headers.extend(process_file(file))

        path_tokens = split_path(path)
        for i in range(len(path_tokens)):
            if path_tokens[i] in {'yb', 'cql', 'yql', 'redis'}:
                libname = '_'.join(reversed(path_tokens[:i]))
                break
        headers.generate(path, libname)


if __name__ == '__main__':
    main()
