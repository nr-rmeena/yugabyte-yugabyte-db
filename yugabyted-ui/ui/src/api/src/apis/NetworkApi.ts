// tslint:disable
/**
 * Yugabyte Cloud
 * YugabyteDB as a Service
 *
 * The version of the OpenAPI document: v1
 * Contact: support@yugabyte.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { useQuery, useInfiniteQuery, useMutation, UseQueryOptions, UseInfiniteQueryOptions, UseMutationOptions } from 'react-query';
import Axios from '../runtime';
import type { AxiosInstance } from 'axios';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import type {
  ApiError,
  NetworkAllowListListResponse,
  NetworkAllowListResponse,
  NetworkAllowListSpec,
  SingleTenantVpcListResponse,
  SingleTenantVpcRequest,
  SingleTenantVpcResponse,
  VpcPeeringListResponse,
  VpcPeeringResponse,
  VpcPeeringSpec,
} from '../models';

export interface CreateNetworkAllowListForQuery {
  accountId: string;
  projectId: string;
  NetworkAllowListSpec?: NetworkAllowListSpec;
}
export interface CreateVpcForQuery {
  accountId: string;
  projectId: string;
  SingleTenantVpcRequest?: SingleTenantVpcRequest;
}
export interface CreateVpcPeeringForQuery {
  accountId: string;
  projectId: string;
  VpcPeeringSpec?: VpcPeeringSpec;
}
export interface DeleteNetworkAllowListForQuery {
  accountId: string;
  projectId: string;
  allowListId: string;
}
export interface DeleteVpcForQuery {
  accountId: string;
  projectId: string;
  vpcId: string;
}
export interface DeleteVpcPeeringForQuery {
  accountId: string;
  projectId: string;
  peeringId: string;
}
export interface GetNetworkAllowListForQuery {
  accountId: string;
  projectId: string;
  allowListId: string;
}
export interface GetSingleTenantVpcForQuery {
  accountId: string;
  projectId: string;
  vpcId: string;
}
export interface GetVpcPeeringForQuery {
  accountId: string;
  projectId: string;
  peeringId: string;
}
export interface ListNetworkAllowListsForQuery {
  accountId: string;
  projectId: string;
}
export interface ListSingleTenantVpcsForQuery {
  accountId: string;
  projectId: string;
  order?: string;
  order_by?: string;
  limit?: number;
  continuation_token?: string;
  name?: string;
  cloud?: ListSingleTenantVpcsCloudEnum;
  region?: string;
  ids?: Set<string>;
}
export interface ListVpcPeeringsForQuery {
  accountId: string;
  projectId: string;
  vpc_id?: string;
  order?: string;
  order_by?: string;
  limit?: number;
  continuation_token?: string;
}

/**
 * Create an allow list
 * Create an allow list entity
 */


export const createNetworkAllowListMutate = (
  body: CreateNetworkAllowListForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/public/accounts/{accountId}/projects/{projectId}/network/allow_lists'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  return Axios<NetworkAllowListResponse>(
    {
      url,
      method: 'POST',
      data: body.NetworkAllowListSpec
    },
    customAxiosInstance
  );
};

export const useCreateNetworkAllowListMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<NetworkAllowListResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<NetworkAllowListResponse, Error, CreateNetworkAllowListForQuery, unknown>((props) => {
    return  createNetworkAllowListMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Create a dedicated VPC
 * Create a dedicated VPC for your DB clusters
 */


export const createVpcMutate = (
  body: CreateVpcForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/public/accounts/{accountId}/projects/{projectId}/network/vpcs'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  return Axios<SingleTenantVpcResponse>(
    {
      url,
      method: 'POST',
      data: body.SingleTenantVpcRequest
    },
    customAxiosInstance
  );
};

export const useCreateVpcMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<SingleTenantVpcResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<SingleTenantVpcResponse, Error, CreateVpcForQuery, unknown>((props) => {
    return  createVpcMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Create a peering
 * Create a peering between customer VPC and Yugabyte VPC
 */


export const createVpcPeeringMutate = (
  body: CreateVpcPeeringForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/public/accounts/{accountId}/projects/{projectId}/network/vpc-peerings'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  return Axios<VpcPeeringResponse>(
    {
      url,
      method: 'POST',
      data: body.VpcPeeringSpec
    },
    customAxiosInstance
  );
};

export const useCreateVpcPeeringMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<VpcPeeringResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<VpcPeeringResponse, Error, CreateVpcPeeringForQuery, unknown>((props) => {
    return  createVpcPeeringMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Delete an allow list
 * Delete an allow list entity
 */


export const deleteNetworkAllowListMutate = (
  body: DeleteNetworkAllowListForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/public/accounts/{accountId}/projects/{projectId}/network/allow_lists/{allowListId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'allowListId'}}`, encodeURIComponent(String(body.allowListId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.allowListId;
  return Axios<unknown>(
    {
      url,
      method: 'DELETE',
    },
    customAxiosInstance
  );
};

export const useDeleteNetworkAllowListMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<unknown, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<unknown, Error, DeleteNetworkAllowListForQuery, unknown>((props) => {
    return  deleteNetworkAllowListMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Delete customer VPC
 * Delete customer-facing VPC by ID
 */


export const deleteVpcMutate = (
  body: DeleteVpcForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/public/accounts/{accountId}/projects/{projectId}/network/vpcs/{vpcId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'vpcId'}}`, encodeURIComponent(String(body.vpcId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.vpcId;
  return Axios<unknown>(
    {
      url,
      method: 'DELETE',
    },
    customAxiosInstance
  );
};

export const useDeleteVpcMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<unknown, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<unknown, Error, DeleteVpcForQuery, unknown>((props) => {
    return  deleteVpcMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Delete VPC Peering
 * Delete VPC Peering
 */


export const deleteVpcPeeringMutate = (
  body: DeleteVpcPeeringForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/public/accounts/{accountId}/projects/{projectId}/network/vpc-peerings/{peeringId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'peeringId'}}`, encodeURIComponent(String(body.peeringId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.peeringId;
  return Axios<unknown>(
    {
      url,
      method: 'DELETE',
    },
    customAxiosInstance
  );
};

export const useDeleteVpcPeeringMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<unknown, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<unknown, Error, DeleteVpcPeeringForQuery, unknown>((props) => {
    return  deleteVpcPeeringMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Retrieve an allow list
 * Retrieve an allow list entity
 */

export const getNetworkAllowListAxiosRequest = (
  requestParameters: GetNetworkAllowListForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<NetworkAllowListResponse>(
    {
      url: '/public/accounts/{accountId}/projects/{projectId}/network/allow_lists/{allowListId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${'allowListId'}}`, encodeURIComponent(String(requestParameters.allowListId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const getNetworkAllowListQueryKey = (
  requestParametersQuery: GetNetworkAllowListForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/public/accounts/{accountId}/projects/{projectId}/network/allow_lists/{allowListId}`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useGetNetworkAllowListInfiniteQuery = <T = NetworkAllowListResponse, Error = ApiError>(
  params: GetNetworkAllowListForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<NetworkAllowListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = getNetworkAllowListQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<NetworkAllowListResponse, Error, T>(
    queryKey,
    () => getNetworkAllowListAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useGetNetworkAllowListQuery = <T = NetworkAllowListResponse, Error = ApiError>(
  params: GetNetworkAllowListForQuery,
  options?: {
    query?: UseQueryOptions<NetworkAllowListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = getNetworkAllowListQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<NetworkAllowListResponse, Error, T>(
    queryKey,
    () => getNetworkAllowListAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Get customer VPC
 * Get customer-facing VPC by ID
 */

export const getSingleTenantVpcAxiosRequest = (
  requestParameters: GetSingleTenantVpcForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<SingleTenantVpcResponse>(
    {
      url: '/public/accounts/{accountId}/projects/{projectId}/network/vpcs/{vpcId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${'vpcId'}}`, encodeURIComponent(String(requestParameters.vpcId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const getSingleTenantVpcQueryKey = (
  requestParametersQuery: GetSingleTenantVpcForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/public/accounts/{accountId}/projects/{projectId}/network/vpcs/{vpcId}`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useGetSingleTenantVpcInfiniteQuery = <T = SingleTenantVpcResponse, Error = ApiError>(
  params: GetSingleTenantVpcForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<SingleTenantVpcResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = getSingleTenantVpcQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<SingleTenantVpcResponse, Error, T>(
    queryKey,
    () => getSingleTenantVpcAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useGetSingleTenantVpcQuery = <T = SingleTenantVpcResponse, Error = ApiError>(
  params: GetSingleTenantVpcForQuery,
  options?: {
    query?: UseQueryOptions<SingleTenantVpcResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = getSingleTenantVpcQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<SingleTenantVpcResponse, Error, T>(
    queryKey,
    () => getSingleTenantVpcAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Get a VPC Peering
 * Get a VPC Peering
 */

export const getVpcPeeringAxiosRequest = (
  requestParameters: GetVpcPeeringForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<VpcPeeringResponse>(
    {
      url: '/public/accounts/{accountId}/projects/{projectId}/network/vpc-peerings/{peeringId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${'peeringId'}}`, encodeURIComponent(String(requestParameters.peeringId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const getVpcPeeringQueryKey = (
  requestParametersQuery: GetVpcPeeringForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/public/accounts/{accountId}/projects/{projectId}/network/vpc-peerings/{peeringId}`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useGetVpcPeeringInfiniteQuery = <T = VpcPeeringResponse, Error = ApiError>(
  params: GetVpcPeeringForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<VpcPeeringResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = getVpcPeeringQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<VpcPeeringResponse, Error, T>(
    queryKey,
    () => getVpcPeeringAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useGetVpcPeeringQuery = <T = VpcPeeringResponse, Error = ApiError>(
  params: GetVpcPeeringForQuery,
  options?: {
    query?: UseQueryOptions<VpcPeeringResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = getVpcPeeringQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<VpcPeeringResponse, Error, T>(
    queryKey,
    () => getVpcPeeringAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Get list of allow lists
 * Get list of allow list entities
 */

export const listNetworkAllowListsAxiosRequest = (
  requestParameters: ListNetworkAllowListsForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<NetworkAllowListListResponse>(
    {
      url: '/public/accounts/{accountId}/projects/{projectId}/network/allow_lists'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const listNetworkAllowListsQueryKey = (
  requestParametersQuery: ListNetworkAllowListsForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/public/accounts/{accountId}/projects/{projectId}/network/allow_lists`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useListNetworkAllowListsInfiniteQuery = <T = NetworkAllowListListResponse, Error = ApiError>(
  params: ListNetworkAllowListsForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<NetworkAllowListListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = listNetworkAllowListsQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<NetworkAllowListListResponse, Error, T>(
    queryKey,
    () => listNetworkAllowListsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useListNetworkAllowListsQuery = <T = NetworkAllowListListResponse, Error = ApiError>(
  params: ListNetworkAllowListsForQuery,
  options?: {
    query?: UseQueryOptions<NetworkAllowListListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = listNetworkAllowListsQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<NetworkAllowListListResponse, Error, T>(
    queryKey,
    () => listNetworkAllowListsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * List customer VPCs
 * Get customer-facing VPCs to choose for cluster isolation
 */

export const listSingleTenantVpcsAxiosRequest = (
  requestParameters: ListSingleTenantVpcsForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<SingleTenantVpcListResponse>(
    {
      url: '/public/accounts/{accountId}/projects/{projectId}/network/vpcs'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))),
      method: 'GET',
      params: {
        order: requestParameters['order'],
        order_by: requestParameters['order_by'],
        limit: requestParameters['limit'],
        continuation_token: requestParameters['continuation_token'],
        name: requestParameters['name'],
        cloud: requestParameters['cloud'],
        region: requestParameters['region'],
        ids: requestParameters['ids'],
      }
    },
    customAxiosInstance
  );
};

export const listSingleTenantVpcsQueryKey = (
  requestParametersQuery: ListSingleTenantVpcsForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/public/accounts/{accountId}/projects/{projectId}/network/vpcs`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useListSingleTenantVpcsInfiniteQuery = <T = SingleTenantVpcListResponse, Error = ApiError>(
  params: ListSingleTenantVpcsForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<SingleTenantVpcListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = listSingleTenantVpcsQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<SingleTenantVpcListResponse, Error, T>(
    queryKey,
    () => listSingleTenantVpcsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useListSingleTenantVpcsQuery = <T = SingleTenantVpcListResponse, Error = ApiError>(
  params: ListSingleTenantVpcsForQuery,
  options?: {
    query?: UseQueryOptions<SingleTenantVpcListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = listSingleTenantVpcsQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<SingleTenantVpcListResponse, Error, T>(
    queryKey,
    () => listSingleTenantVpcsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * List peerings
 * List peerings between customer VPCs and Yugabyte VPCs
 */

export const listVpcPeeringsAxiosRequest = (
  requestParameters: ListVpcPeeringsForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<VpcPeeringListResponse>(
    {
      url: '/public/accounts/{accountId}/projects/{projectId}/network/vpc-peerings'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))),
      method: 'GET',
      params: {
        vpc_id: requestParameters['vpc_id'],
        order: requestParameters['order'],
        order_by: requestParameters['order_by'],
        limit: requestParameters['limit'],
        continuation_token: requestParameters['continuation_token'],
      }
    },
    customAxiosInstance
  );
};

export const listVpcPeeringsQueryKey = (
  requestParametersQuery: ListVpcPeeringsForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/public/accounts/{accountId}/projects/{projectId}/network/vpc-peerings`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useListVpcPeeringsInfiniteQuery = <T = VpcPeeringListResponse, Error = ApiError>(
  params: ListVpcPeeringsForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<VpcPeeringListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = listVpcPeeringsQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<VpcPeeringListResponse, Error, T>(
    queryKey,
    () => listVpcPeeringsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useListVpcPeeringsQuery = <T = VpcPeeringListResponse, Error = ApiError>(
  params: ListVpcPeeringsForQuery,
  options?: {
    query?: UseQueryOptions<VpcPeeringListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = listVpcPeeringsQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<VpcPeeringListResponse, Error, T>(
    queryKey,
    () => listVpcPeeringsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};







/**
  * @export
  * @enum {string}
  */
export enum ListSingleTenantVpcsCloudEnum {
  Aws = 'AWS',
  Gcp = 'GCP'
}
