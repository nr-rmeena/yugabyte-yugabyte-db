// tslint:disable
/**
 * Yugabyte Cloud
 * YugabyteDB as a Service
 *
 * The version of the OpenAPI document: v1
 * Contact: support@yugabyte.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { useQuery, useInfiniteQuery, useMutation, UseQueryOptions, UseInfiniteQueryOptions, UseMutationOptions } from 'react-query';
import Axios from '../runtime';
import type { AxiosInstance } from 'axios';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import type {
  ApiError,
  ClusterResponse,
  CreatePrivateClusterRequest,
  DBReleasesListResponse,
  DbUpgradeRequest,
  GFlagsDataResponse,
  GflagsUpgradeRequest,
  InternalClusterResponse,
  PlatformResponse,
  PrivateClusterSpec,
  RebuildMetricsTargetsRequest,
  VmUpgradeRequest,
} from '../models';

export interface CreatePrivateClusterForQuery {
  accountId: string;
  projectId: string;
  CreatePrivateClusterRequest?: CreatePrivateClusterRequest;
}
export interface DbUpgradeForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
  DbUpgradeRequest?: DbUpgradeRequest;
}
export interface EditPrivateClusterForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
  PrivateClusterSpec?: PrivateClusterSpec;
}
export interface GetClusterInternalDetailsForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
}
export interface GetDbReleasesForQuery {
  versionPrefixes: Array<string>;
}
export interface GetPlatformForClusterForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
}
export interface GflagsUpgradeForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
  GflagsUpgradeRequest?: GflagsUpgradeRequest;
}
export interface ListGFlagsForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
}
export interface LockClusterForSupportForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
}
export interface RebuildScrapeTargetsForQuery {
  RebuildMetricsTargetsRequest?: RebuildMetricsTargetsRequest;
}
export interface UnlockClusterForSupportForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
}
export interface VmUpgradeForQuery {
  accountId: string;
  projectId: string;
  clusterId: string;
  VmUpgradeRequest?: VmUpgradeRequest;
}

/**
 * Create a new Private Yugabyte Cluster
 * Create a Private cluster
 */


export const createPrivateClusterMutate = (
  body: CreatePrivateClusterForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  return Axios<ClusterResponse>(
    {
      url,
      method: 'POST',
      data: body.CreatePrivateClusterRequest
    },
    customAxiosInstance
  );
};

export const useCreatePrivateClusterMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<ClusterResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<ClusterResponse, Error, CreatePrivateClusterForQuery, unknown>((props) => {
    return  createPrivateClusterMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Submit task to upgrade DB version of a cluster
 * Submit task to upgrade DB version of a cluster
 */


export const dbUpgradeMutate = (
  body: DbUpgradeForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/upgrade/db'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(body.clusterId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.clusterId;
  return Axios<ClusterResponse>(
    {
      url,
      method: 'POST',
      data: body.DbUpgradeRequest
    },
    customAxiosInstance
  );
};

export const useDbUpgradeMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<ClusterResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<ClusterResponse, Error, DbUpgradeForQuery, unknown>((props) => {
    return  dbUpgradeMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Submit task to edit a private Yugabyte Cluster
 * Submit task to edit a private cluster
 */


export const editPrivateClusterMutate = (
  body: EditPrivateClusterForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(body.clusterId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.clusterId;
  return Axios<ClusterResponse>(
    {
      url,
      method: 'PUT',
      data: body.PrivateClusterSpec
    },
    customAxiosInstance
  );
};

export const useEditPrivateClusterMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<ClusterResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<ClusterResponse, Error, EditPrivateClusterForQuery, unknown>((props) => {
    return  editPrivateClusterMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Get a Yugabyte Cluster along with internal cluster info
 * Get a cluster
 */

export const getClusterInternalDetailsAxiosRequest = (
  requestParameters: GetClusterInternalDetailsForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<InternalClusterResponse>(
    {
      url: '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(requestParameters.clusterId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const getClusterInternalDetailsQueryKey = (
  requestParametersQuery: GetClusterInternalDetailsForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useGetClusterInternalDetailsInfiniteQuery = <T = InternalClusterResponse, Error = ApiError>(
  params: GetClusterInternalDetailsForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<InternalClusterResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = getClusterInternalDetailsQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<InternalClusterResponse, Error, T>(
    queryKey,
    () => getClusterInternalDetailsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useGetClusterInternalDetailsQuery = <T = InternalClusterResponse, Error = ApiError>(
  params: GetClusterInternalDetailsForQuery,
  options?: {
    query?: UseQueryOptions<InternalClusterResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = getClusterInternalDetailsQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<InternalClusterResponse, Error, T>(
    queryKey,
    () => getClusterInternalDetailsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Get all the available DB releases for upgrade
 * Get all the available DB releases for upgrade
 */

export const getDbReleasesAxiosRequest = (
  requestParameters: GetDbReleasesForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<DBReleasesListResponse>(
    {
      url: '/private/db_releases',
      method: 'GET',
      params: {
        versionPrefixes: requestParameters['versionPrefixes'],
      }
    },
    customAxiosInstance
  );
};

export const getDbReleasesQueryKey = (
  requestParametersQuery: GetDbReleasesForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/private/db_releases`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useGetDbReleasesInfiniteQuery = <T = DBReleasesListResponse, Error = ApiError>(
  params: GetDbReleasesForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<DBReleasesListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = getDbReleasesQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<DBReleasesListResponse, Error, T>(
    queryKey,
    () => getDbReleasesAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useGetDbReleasesQuery = <T = DBReleasesListResponse, Error = ApiError>(
  params: GetDbReleasesForQuery,
  options?: {
    query?: UseQueryOptions<DBReleasesListResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = getDbReleasesQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<DBReleasesListResponse, Error, T>(
    queryKey,
    () => getDbReleasesAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Get data of platform which manages the given cluster
 * Get data of platform which manages the given cluster
 */

export const getPlatformForClusterAxiosRequest = (
  requestParameters: GetPlatformForClusterForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<PlatformResponse>(
    {
      url: '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/platform'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(requestParameters.clusterId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const getPlatformForClusterQueryKey = (
  requestParametersQuery: GetPlatformForClusterForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/platform`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useGetPlatformForClusterInfiniteQuery = <T = PlatformResponse, Error = ApiError>(
  params: GetPlatformForClusterForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<PlatformResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = getPlatformForClusterQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<PlatformResponse, Error, T>(
    queryKey,
    () => getPlatformForClusterAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useGetPlatformForClusterQuery = <T = PlatformResponse, Error = ApiError>(
  params: GetPlatformForClusterForQuery,
  options?: {
    query?: UseQueryOptions<PlatformResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = getPlatformForClusterQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<PlatformResponse, Error, T>(
    queryKey,
    () => getPlatformForClusterAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Submit task to upgrade gflags of Yugabyte cluster
 * Submit task to upgrade gflags of a cluster
 */


export const gflagsUpgradeMutate = (
  body: GflagsUpgradeForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/gflags'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(body.clusterId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.clusterId;
  return Axios<ClusterResponse>(
    {
      url,
      method: 'POST',
      data: body.GflagsUpgradeRequest
    },
    customAxiosInstance
  );
};

export const useGflagsUpgradeMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<ClusterResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<ClusterResponse, Error, GflagsUpgradeForQuery, unknown>((props) => {
    return  gflagsUpgradeMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * List all GFlags on a cluster
 * List all GFlags on a cluster
 */

export const listGFlagsAxiosRequest = (
  requestParameters: ListGFlagsForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  return Axios<GFlagsDataResponse>(
    {
      url: '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/gflags'.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(requestParameters.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(requestParameters.clusterId))),
      method: 'GET',
      params: {
      }
    },
    customAxiosInstance
  );
};

export const listGFlagsQueryKey = (
  requestParametersQuery: ListGFlagsForQuery,
  pageParam = -1,
  version = 1,
) => [
  `/v${version}/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/gflags`,
  pageParam,
  ...(requestParametersQuery ? [requestParametersQuery] : [])
];


export const useListGFlagsInfiniteQuery = <T = GFlagsDataResponse, Error = ApiError>(
  params: ListGFlagsForQuery,
  options?: {
    query?: UseInfiniteQueryOptions<GFlagsDataResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  pageParam = -1,
  version = 1,
) => {
  const queryKey = listGFlagsQueryKey(params, pageParam, version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useInfiniteQuery<GFlagsDataResponse, Error, T>(
    queryKey,
    () => listGFlagsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

export const useListGFlagsQuery = <T = GFlagsDataResponse, Error = ApiError>(
  params: ListGFlagsForQuery,
  options?: {
    query?: UseQueryOptions<GFlagsDataResponse, Error, T>;
    customAxiosInstance?: AxiosInstance;
  },
  version = 1,
) => {
  const queryKey = listGFlagsQueryKey(params,  version);
  const { query: queryOptions, customAxiosInstance } = options ?? {};

  const query = useQuery<GFlagsDataResponse, Error, T>(
    queryKey,
    () => listGFlagsAxiosRequest(params, customAxiosInstance),
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};



/**
 * Acquire lock on the cluster
 * Acquire lock on the cluster
 */


export const lockClusterForSupportMutate = (
  body: LockClusterForSupportForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/lock'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(body.clusterId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.clusterId;
  return Axios<unknown>(
    {
      url,
      method: 'POST',
    },
    customAxiosInstance
  );
};

export const useLockClusterForSupportMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<unknown, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<unknown, Error, LockClusterForSupportForQuery, unknown>((props) => {
    return  lockClusterForSupportMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Rebuild metrics scrape targets
 * Rebuild prometheus configmap for scrape targets
 */


export const rebuildScrapeTargetsMutate = (
  body: RebuildScrapeTargetsForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/clusters/scrape_targets';
  return Axios<unknown>(
    {
      url,
      method: 'PUT',
      data: body.RebuildMetricsTargetsRequest
    },
    customAxiosInstance
  );
};

export const useRebuildScrapeTargetsMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<unknown, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<unknown, Error, RebuildScrapeTargetsForQuery, unknown>((props) => {
    return  rebuildScrapeTargetsMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Release lock on the cluster
 * Release lock on the cluster
 */


export const unlockClusterForSupportMutate = (
  body: UnlockClusterForSupportForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/unlock'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(body.clusterId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.clusterId;
  return Axios<unknown>(
    {
      url,
      method: 'POST',
    },
    customAxiosInstance
  );
};

export const useUnlockClusterForSupportMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<unknown, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<unknown, Error, UnlockClusterForSupportForQuery, unknown>((props) => {
    return  unlockClusterForSupportMutate(props, customAxiosInstance);
  }, mutationOptions);
};


/**
 * Submit task to upgrade VM image of a cluster
 * Submit task to upgrade VM image of a cluster
 */


export const vmUpgradeMutate = (
  body: VmUpgradeForQuery,
  customAxiosInstance?: AxiosInstance
) => {
  const url = '/private/accounts/{accountId}/projects/{projectId}/clusters/{clusterId}/upgrade/vm'.replace(`{${'accountId'}}`, encodeURIComponent(String(body.accountId))).replace(`{${'projectId'}}`, encodeURIComponent(String(body.projectId))).replace(`{${'clusterId'}}`, encodeURIComponent(String(body.clusterId)));
  // eslint-disable-next-line
  // @ts-ignore
  delete body.accountId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.projectId;
  // eslint-disable-next-line
  // @ts-ignore
  delete body.clusterId;
  return Axios<ClusterResponse>(
    {
      url,
      method: 'POST',
      data: body.VmUpgradeRequest
    },
    customAxiosInstance
  );
};

export const useVmUpgradeMutation = <Error = ApiError>(
  options?: {
    mutation?:UseMutationOptions<ClusterResponse, Error>,
    customAxiosInstance?: AxiosInstance;
  }
) => {
  const {mutation: mutationOptions, customAxiosInstance} = options ?? {};
  // eslint-disable-next-line
  // @ts-ignore
  return useMutation<ClusterResponse, Error, VmUpgradeForQuery, unknown>((props) => {
    return  vmUpgradeMutate(props, customAxiosInstance);
  }, mutationOptions);
};





